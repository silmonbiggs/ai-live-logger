<!DOCTYPE html>
<html>
<head>
    <title>ChatGPT Live Logger - Auto Injector</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #00ff00; }
        .status { margin: 10px 0; padding: 10px; border: 1px solid #333; background: #222; }
        .success { border-color: #00aa00; }
        .error { border-color: #aa0000; color: #ff0000; }
        .script-content { font-size: 10px; max-height: 200px; overflow-y: auto; background: #333; padding: 10px; }
        .controls { margin: 20px 0; }
        button { padding: 10px 20px; margin: 5px; background: #333; color: #00ff00; border: 1px solid #666; cursor: pointer; }
        button:hover { background: #444; }
    </style>
</head>
<body>
    <h1>ü§ñ ChatGPT Live Logger - Auto Injector</h1>
    <p>This page will automatically inject the detection scripts when loaded.</p>
    
    <div class="controls">
        <button onclick="injectScripts()">üîÑ Re-inject Scripts</button>
        <button onclick="testConnection()">üîó Test Server</button>
        <button onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
        <button onclick="checkStats()">üìä Check Stats</button>
    </div>
    
    <div id="status" class="status">
        <div>Status: Initializing...</div>
    </div>
    
    <div class="status">
        <div>Enhanced Script: 20190 characters</div>
        <div class="script-content">// Enhanced User Detection Logger - Fixes broken user send detection in Claude interface
// This fixes the core issue where onUserSendMessage() never gets called
// Copy this entire content and paste it into Claude's F12 console

(function() {
  'use strict';
  
  const LOGGER_NAME = '[ENHANCED USER DETECTION]';
  console.log(`${LOGGER_NAME} Initializing comprehensive user send detection...`);
  
  // Storage for user interaction tracking
  const state = {
    // Message tracking
    processedMe...</div>
    </div>
    
    <div class="status">
        <div>Signal Script: 32607 characters</div>
        <div class="script-content">// Updated signal processing logger with J prefix and preservation fixes
// Copy this entire content and paste it into Claude's F12 console// Signal Processing Claude Logger - Multi-layer filtering for clean chat.log
(function() {
  'use strict';
  
  const LOGGER_NAME = '[SIGNAL PROCESSING LOGGER]';
  console.log(`${LOGGER_NAME} Initializing multi-layer signal processing filter...`);
  
  // Storage for conversation state and signal analysis
  const state = {
    // Message tracking
    process...</div>
    </div>

    <script>
        const status = document.getElementById('status');
        
        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            status.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            status.scrollTop = status.scrollHeight;
        }
        
        function testConnection() {
            log('Testing server connection...');
            fetch('http://localhost:8788/health')
                .then(response => {
                    if (response.ok) {
                        log('‚úÖ Server connection successful');
                    } else {
                        log('‚ùå Server responded with error: ' + response.status);
                    }
                })
                .catch(error => {
                    log('‚ùå Server connection failed: ' + error.message);
                });
        }
        
        function clearLogs() {
            log('Clearing server logs...');
            // This would need server endpoint to clear logs
            log('‚ö†Ô∏è Log clearing not implemented yet');
        }
        
        function checkStats() {
            log('Checking detection statistics...');
            
            if (window.enhancedUserDetection) {
                const stats = window.enhancedUserDetection.getStats();
                log('üìä Enhanced Detection Stats: ' + JSON.stringify(stats));
            } else {
                log('‚ùå Enhanced user detection not active');
            }
            
            if (window.signalProcessingLogger) {
                const stats = window.signalProcessingLogger.getStats();
                log('üìä Signal Processing Stats: ' + JSON.stringify(stats));
            } else {
                log('‚ùå Signal processing logger not active');
            }
            
            if (window.genuineUserInputs) {
                log('üìä Genuine Inputs Marked: ' + window.genuineUserInputs.size);
            } else {
                log('‚ùå No genuine user inputs marked');
            }
        }
        
        function injectScripts() {
            log('üöÄ Starting script injection...');
            
            // Inject enhanced user detection script
            try {
                log('Injecting enhanced user detection script...');
                const enhancedScript = `// Enhanced User Detection Logger - Fixes broken user send detection in Claude interface
// This fixes the core issue where onUserSendMessage() never gets called
// Copy this entire content and paste it into Claude's F12 console

(function() {
  'use strict';
  
  const LOGGER_NAME = '[ENHANCED USER DETECTION]';
  console.log(\`\${LOGGER_NAME} Initializing comprehensive user send detection...\`);
  
  // Storage for user interaction tracking
  const state = {
    // Message tracking
    processedMessages: new Map(),
    messageSequence: [],
    conversationHistory: [],
    
    // User interaction detection
    lastUserInteraction: 0,
    sessionStart: Date.now(),
    
    // Enhanced user send detection
    userSendTracking: {
      awaitingResponse: false,
      responseToContent: null,
      userSentAt: 0,
      seenUserMessageInStream: false,
      genuineResponseCaptured: false,
      responseWindow: 15000,
      inputTrackingActive: false,
      lastInputContent: '',
      inputElementObserver: null
    },
    
    // User send detection statistics
    detectionStats: {
      sendButtonClicks: 0,
      keyboardSubmissions: 0,
      inputDetections: 0,
      webSocketMessages: 0,
      formSubmissions: 0,
      successfulDetections: 0,
      missedDetections: 0
    },
    
    // Grace period handling for legitimate repeats
    gracePeriod: 10000, // 10 seconds grace period for legitimate repeats
    lastProcessedContent: '',
    lastProcessedTime: 0
  };
  
  /**
   * MAIN FIX: Multi-layered user send detection
   * This replaces the broken setupUserSendDetection() function
   */
  function setupComprehensiveUserSendDetection() {
    console.log(\`\${LOGGER_NAME} üîß Setting up comprehensive user send detection...\`);
    
    // LAYER 1: Send Button Click Detection
    setupSendButtonDetection();
    
    // LAYER 2: Keyboard Submission Detection (Enter key)
    setupKeyboardDetection();
    
    // LAYER 3: Input Field Monitoring
    setupInputFieldMonitoring();
    
    // LAYER 4: Form Submission Detection
    setupFormSubmissionDetection();
    
    // LAYER 5: WebSocket Message Interception
    setupWebSocketInterception();
    
    // LAYER 6: MutationObserver for Send Button State Changes
    setupSendButtonStateMonitoring();
    
    console.log(\`\${LOGGER_NAME} ‚úÖ All detection layers initialized\`);
  }
  
  /**
   * LAYER 1: Send Button Click Detection
   * Monitors clicks on potential send buttons using multiple selectors
   */
  function setupSendButtonDetection() {
    const sendButtonSelectors = [
      // Common send button selectors
      'button[aria-label*="Send"]',
      'button[title*="Send"]',
      'button[type="submit"]',
      'button:contains("Send")',
      '[data-testid="send-button"]',
      '[data-cy="send-button"]',
      '.send-button',
      '.submit-button',
      // Claude-specific selectors (discovered via inspection)
      'button[aria-label*="send"]',
      'button[aria-label*="Submit"]',
      'button svg[data-icon="send"]',
      // Generic button detection near input areas
      'form button',
      'div[contenteditable] + button',
      'textarea + button',
      'input[type="text"] + button'
    ];
    
    // Use event delegation to catch all button clicks
    document.addEventListener('click', function(event) {
      const target = event.target;
      
      // Check if clicked element matches any send button selector
      const isSendButton = sendButtonSelectors.some(selector => {
        try {
          return target.matches(selector) || target.closest(selector);
        } catch (e) {
          return false;
        }
      });
      
      if (isSendButton) {
        console.log(\`\${LOGGER_NAME} üéØ SEND BUTTON CLICK DETECTED:\`, target);
        state.detectionStats.sendButtonClicks++;
        
        // Capture user input content
        const userContent = captureUserInputContent();
        if (userContent && userContent.trim()) {
          onUserSendMessage(userContent, 'send_button_click');
        }
      }
      
      // Also check for any button near input fields
      const nearbyInput = findNearbyInputElement(target);
      if (nearbyInput) {
        const inputContent = getInputElementValue(nearbyInput);
        if (inputContent && inputContent.trim() && target.tagName === 'BUTTON') {
          console.log(\`\${LOGGER_NAME} üéØ BUTTON NEAR INPUT DETECTED:\`, target, 'input:', inputContent.slice(0, 30));
          state.detectionStats.sendButtonClicks++;
          onUserSendMessage(inputContent, 'button_near_input');
        }
      }
    }, true); // Use capture phase
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Send button detection active with \${sendButtonSelectors.length} selectors\`);
  }
  
  /**
   * LAYER 2: Keyboard Submission Detection
   * Monitors Enter key presses and Ctrl+Enter combinations
   */
  function setupKeyboardDetection() {
    document.addEventListener('keydown', function(event) {
      // Check for submission key combinations
      const isSubmissionKey = (
        (event.key === 'Enter' && !event.shiftKey) ||  // Enter without Shift
        (event.key === 'Enter' && event.ctrlKey) ||    // Ctrl+Enter
        (event.key === 'Enter' && event.metaKey)       // Cmd+Enter (Mac)
      );
      
      if (isSubmissionKey) {
        const target = event.target;
        
        // Check if we're in an input element
        if (target.matches('input, textarea, [contenteditable="true"], [contenteditable=""]')) {
          console.log(\`\${LOGGER_NAME} üéØ KEYBOARD SUBMISSION DETECTED:\`, target.tagName, event.key);
          state.detectionStats.keyboardSubmissions++;
          
          const userContent = getInputElementValue(target);
          if (userContent && userContent.trim()) {
            // Add small delay to ensure content is captured
            setTimeout(() => {
              onUserSendMessage(userContent, 'keyboard_submission');
            }, 50);
          }
        }
      }
    }, true);
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Keyboard submission detection active\`);
  }
  
  /**
   * LAYER 3: Input Field Monitoring
   * Tracks changes in input fields and potential submissions
   */
  function setupInputFieldMonitoring() {
    const inputSelectors = [
      'input[type="text"]',
      'textarea',
      '[contenteditable="true"]',
      '[contenteditable=""]',
      '[role="textbox"]'
    ];
    
    // Monitor input changes
    document.addEventListener('input', function(event) {
      const target = event.target;
      
      if (inputSelectors.some(selector => {
        try { return target.matches(selector); } catch(e) { return false; }
      })) {
        const content = getInputElementValue(target);
        state.userSendTracking.lastInputContent = content;
        state.detectionStats.inputDetections++;
        
        // Track that user is actively typing
        state.lastUserInteraction = Date.now();
        state.userSendTracking.inputTrackingActive = true;
      }
    });
    
    // Monitor focus events to identify active input
    document.addEventListener('focusin', function(event) {
      const target = event.target;
      
      if (inputSelectors.some(selector => {
        try { return target.matches(selector); } catch(e) { return false; }
      })) {
        console.log(\`\${LOGGER_NAME} üìç Input field focused:\`, target.tagName);
        
        // Set up observer for this specific input element
        if (state.userSendTracking.inputElementObserver) {
          state.userSendTracking.inputElementObserver.disconnect();
        }
        
        // Monitor for value changes on the focused element
        state.userSendTracking.inputElementObserver = new MutationObserver(() => {
          const content = getInputElementValue(target);
          if (content !== state.userSendTracking.lastInputContent) {
            state.userSendTracking.lastInputContent = content;
            state.lastUserInteraction = Date.now();
          }
        });
        
        state.userSendTracking.inputElementObserver.observe(target, {
          attributes: true,
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Input field monitoring active\`);
  }
  
  /**
   * LAYER 4: Form Submission Detection
   * Monitors form submissions that might contain user messages
   */
  function setupFormSubmissionDetection() {
    document.addEventListener('submit', function(event) {
      console.log(\`\${LOGGER_NAME} üéØ FORM SUBMISSION DETECTED:\`, event.target);
      state.detectionStats.formSubmissions++;
      
      const form = event.target;
      const formData = new FormData(form);
      
      // Try to find user input in form data
      for (const [key, value] of formData.entries()) {
        if (typeof value === 'string' && value.trim() && value.length > 2) {
          console.log(\`\${LOGGER_NAME} Form field "\${key}":\`, value.slice(0, 50));
          onUserSendMessage(value, 'form_submission');
          break; // Take first meaningful value
        }
      }
      
      // Also check input elements within the form
      const inputs = form.querySelectorAll('input, textarea, [contenteditable]');
      for (const input of inputs) {
        const content = getInputElementValue(input);
        if (content && content.trim()) {
          onUserSendMessage(content, 'form_input_element');
          break;
        }
      }
    }, true);
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Form submission detection active\`);
  }
  
  /**
   * LAYER 5: WebSocket Message Interception
   * Intercepts WebSocket messages to catch user submissions
   */
  function setupWebSocketInterception() {
    try {
      // Store original WebSocket constructor
      const OriginalWebSocket = window.WebSocket;
      
      // Override WebSocket constructor
      window.WebSocket = function(url, protocols) {
        console.log(\`\${LOGGER_NAME} üîó WebSocket connection detected:\`, url);
        
        const ws = new OriginalWebSocket(url, protocols);
        
        // Override send method
        const originalSend = ws.send;
        ws.send = function(data) {
          console.log(\`\${LOGGER_NAME} üì° WebSocket message sent:\`, typeof data, data ? data.toString().slice(0, 100) : 'empty');
          state.detectionStats.webSocketMessages++;
          
          // Try to parse and extract user content
          if (typeof data === 'string') {
            try {
              const parsed = JSON.parse(data);
              if (parsed.message || parsed.content || parsed.text) {
                const userContent = parsed.message || parsed.content || parsed.text;
                console.log(\`\${LOGGER_NAME} üéØ User content in WebSocket:\`, userContent.slice(0, 50));
                onUserSendMessage(userContent, 'websocket_message');
              }
            } catch (e) {
              // Not JSON, check if it looks like user input
              if (data.length > 5 && data.length < 2000) {
                onUserSendMessage(data, 'websocket_raw');
              }
            }
          }
          
          return originalSend.call(this, data);
        };
        
        return ws;
      };
      
      // Copy static properties
      Object.setPrototypeOf(window.WebSocket, OriginalWebSocket);
      Object.defineProperty(window.WebSocket, 'prototype', {
        value: OriginalWebSocket.prototype,
        writable: false
      });
      
      console.log(\`\${LOGGER_NAME} ‚úÖ WebSocket interception active\`);
    } catch (error) {
      console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è WebSocket interception failed:\`, error.message);
    }
  }
  
  /**
   * LAYER 6: Send Button State Monitoring
   * Monitors for send button state changes (disabled -> enabled) which often indicates ready to send
   */
  function setupSendButtonStateMonitoring() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'disabled') {
          const target = mutation.target;
          
          // Check if this is potentially a send button
          if (target.tagName === 'BUTTON') {
            const wasDisabled = mutation.oldValue === 'disabled' || mutation.oldValue === '';
            const isNowEnabled = !target.disabled;
            
            if (wasDisabled && isNowEnabled) {
              console.log(\`\${LOGGER_NAME} üîÑ Send button enabled:\`, target);
              
              // Button just became enabled - user might have entered content
              const userContent = captureUserInputContent();
              if (userContent && userContent.trim()) {
                // Don't immediately trigger, wait for actual click/submit
                state.userSendTracking.lastInputContent = userContent;
              }
            }
          }
        }
      });
    });
    
    observer.observe(document.body, {
      attributes: true,
      subtree: true,
      attributeFilter: ['disabled'],
      attributeOldValue: true
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Send button state monitoring active\`);
  }
  
  /**
   * Helper function to capture user input content from various sources
   */
  function captureUserInputContent() {
    // Try multiple strategies to find user input content
    
    // 1. Check tracked input content
    if (state.userSendTracking.lastInputContent && 
        state.userSendTracking.lastInputContent.trim()) {
      return state.userSendTracking.lastInputContent;
    }
    
    // 2. Find focused input element
    const focused = document.activeElement;
    if (focused && focused.matches('input, textarea, [contenteditable]')) {
      const content = getInputElementValue(focused);
      if (content && content.trim()) {
        return content;
      }
    }
    
    // 3. Find input elements with content
    const inputElements = document.querySelectorAll('input, textarea, [contenteditable="true"], [contenteditable=""]');
    for (const element of inputElements) {
      const content = getInputElementValue(element);
      if (content && content.trim() && content.length > 2) {
        return content;
      }
    }
    
    return null;
  }
  
  /**
   * Helper function to get value from various input element types
   */
  function getInputElementValue(element) {
    if (!element) return '';
    
    if (element.value !== undefined) {
      return element.value;
    }
    
    if (element.contentEditable === 'true' || element.contentEditable === '') {
      return element.textContent || element.innerText || '';
    }
    
    return element.textContent || element.innerText || '';
  }
  
  /**
   * Helper function to find nearby input elements
   */
  function findNearbyInputElement(target) {
    // Check parent elements for input fields
    let current = target.parentElement;
    let depth = 0;
    
    while (current && depth < 5) {
      const inputs = current.querySelectorAll('input, textarea, [contenteditable]');
      if (inputs.length > 0) {
        return inputs[inputs.length - 1]; // Return the last (most recent) input
      }
      current = current.parentElement;
      depth++;
    }
    
    // Check siblings
    const siblings = target.parentElement ? target.parentElement.querySelectorAll('input, textarea, [contenteditable]') : [];
    return siblings.length > 0 ? siblings[siblings.length - 1] : null;
  }
  
  /**
   * ENHANCED USER SEND DETECTION - Fixed implementation
   * This is the function that was broken in the original code
   */
  function onUserSendMessage(userContent, detectionMethod) {
    const now = Date.now();
    
    if (!userContent || !userContent.trim()) {
      console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è Empty user content, skipping detection\`);
      return;
    }
    
    console.log(\`\${LOGGER_NAME} üéØ USER SEND DETECTED via \${detectionMethod}: "\${userContent.slice(0, 50)}..."\`);
    
    // Check for duplicate detection within grace period
    if (state.lastProcessedContent === userContent && 
        (now - state.lastProcessedTime) < state.gracePeriod) {
      console.log(\`\${LOGGER_NAME} üîÑ Ignoring duplicate detection within grace period (\${now - state.lastProcessedTime}ms)\`);
      return;
    }
    
    // Update tracking
    state.lastProcessedContent = userContent;
    state.lastProcessedTime = now;
    state.detectionStats.successfulDetections++;
    
    // Check if we're already awaiting a response (prevent multiple triggers)
    if (state.userSendTracking.awaitingResponse) {
      const timeSinceLastSend = now - state.userSendTracking.userSentAt;
      if (timeSinceLastSend < 2000) {
        console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è Ignoring duplicate send event (\${timeSinceLastSend}ms since last)\`);
        return;
      }
    }
    
    // Set up tracking for genuine message and response detection
    state.userSendTracking.awaitingResponse = true;
    state.userSendTracking.responseToContent = userContent;
    state.userSendTracking.userSentAt = now;
    state.userSendTracking.seenUserMessageInStream = false;
    state.userSendTracking.genuineResponseCaptured = false;
    
    // Update lastUserInteraction as well
    state.lastUserInteraction = now;
    
    console.log(\`\${LOGGER_NAME} üìç Tracking genuine user-assistant exchange for: "\${userContent.slice(0, 30)}..."\`);
    console.log(\`\${LOGGER_NAME} üìç Detection method: \${detectionMethod}\`);
    console.log(\`\${LOGGER_NAME} üìç User message window: 5s, Response window: \${state.userSendTracking.responseWindow}ms\`);
    
    // Mark this as a genuine user input for bypass filtering
    markAsGenuineUserInput(userContent, detectionMethod);
  }
  
  /**
   * Mark content as genuine user input to bypass filtering
   */
  function markAsGenuineUserInput(content, detectionMethod) {
    // Store this as a genuine user input with timestamp
    if (!window.signalProcessingLogger) {
      console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è Signal processing logger not found, creating bypass marker\`);
      window.genuineUserInputs = window.genuineUserInputs || new Map();
    }
    
    const timestamp = Date.now();
    const marker = {
      content: content,
      timestamp: timestamp,
      detectionMethod: detectionMethod,
      genuine: true
    };
    
    // Store in global scope for signal processing logger to access
    window.genuineUserInputs = window.genuineUserInputs || new Map();
    window.genuineUserInputs.set(content, marker);
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Marked as genuine user input: "\${content.slice(0, 30)}..." via \${detectionMethod}\`);
    
    // Clean up old markers (older than 30 seconds)
    for (const [key, value] of window.genuineUserInputs.entries()) {
      if (timestamp - value.timestamp > 30000) {
        window.genuineUserInputs.delete(key);
      }
    }
  }
  
  /**
   * Get detection statistics
   */
  function getDetectionStats() {
    return {
      ...state.detectionStats,
      uptime: Date.now() - state.sessionStart,
      genuineInputsMarked: window.genuineUserInputs ? window.genuineUserInputs.size : 0
    };
  }
  
  /**
   * Initialize the enhanced user detection system
   */
  function initialize() {
    console.log(\`\${LOGGER_NAME} üöÄ Starting enhanced user detection system...\`);
    
    setupComprehensiveUserSendDetection();
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Enhanced user detection system ready!\`);
    console.log(\`\${LOGGER_NAME} Monitoring for user inputs via:\`)
    console.log(\`  - Send button clicks\`);
    console.log(\`  - Keyboard submissions (Enter, Ctrl+Enter)\`);
    console.log(\`  - Input field monitoring\`);
    console.log(\`  - Form submissions\`);
    console.log(\`  - WebSocket message interception\`);
    console.log(\`  - Send button state changes\`);
  }
  
  // Start the enhanced detection system
  initialize();
  
  // Expose for debugging
  window.enhancedUserDetection = {
    getStats: getDetectionStats,
    getState: () => state,
    markAsGenuine: markAsGenuineUserInput,
    testDetection: (content) => onUserSendMessage(content, 'manual_test')
  };
  
  console.log(\`\${LOGGER_NAME} üîß Debug available: window.enhancedUserDetection.getStats(), .getState(), .testDetection()\`);
  
})();`;
                
                if (enhancedScript.length > 100) {
                    eval(enhancedScript);
                    log('‚úÖ Enhanced user detection script injected');
                } else {
                    log('‚ùå Enhanced script is too short or empty');
                }
            } catch (error) {
                log('‚ùå Enhanced script injection failed: ' + error.message);
            }
            
            // Small delay between scripts
            setTimeout(() => {
                try {
                    log('Injecting signal processing script...');
                    const signalScript = `// Updated signal processing logger with J prefix and preservation fixes
// Copy this entire content and paste it into Claude's F12 console// Signal Processing Claude Logger - Multi-layer filtering for clean chat.log
(function() {
  'use strict';
  
  const LOGGER_NAME = '[SIGNAL PROCESSING LOGGER]';
  console.log(\`\${LOGGER_NAME} Initializing multi-layer signal processing filter...\`);
  
  // Storage for conversation state and signal analysis
  const state = {
    // Message tracking
    processedMessages: new Map(),
    messageSequence: [],
    conversationHistory: [],
    
    // Signal processing buffers
    velocityBuffer: [], // Recent message timing analysis
    hashBuffer: [], // For autocorrelation pattern detection
    temporalWindow: [], // Conversation context window
    
    // User interaction tracking
    lastUserInteraction: 0,
    sessionStart: Date.now(),
    
    // Enhanced user send detection for sequence tracking
    userSendTracking: {
      awaitingResponse: false,
      responseToContent: null,
      userSentAt: 0,
      seenUserMessageInStream: false,
      genuineResponseCaptured: false,
      responseWindow: 15000 // 15 seconds max for response
    },
    
    // Filter statistics
    stats: {
      totalMessages: 0,
      filteredByVelocity: 0,
      filteredByTemporal: 0,
      filteredByEcho: 0,
      filteredByAutocorrelation: 0,
      preservedByContext: 0,
      cleanLogEntries: 0,
      verboseLogEntries: 0
    }
  };
  
  // Filter configuration
  const config = {
    // Velocity filter (bulk dump detection)
    velocityThreshold: 5, // Messages per second threshold
    velocityWindow: 1000, // 1 second window
    
    // Temporal filter (conversation window)
    conversationWindow: 300000, // 5 minutes
    userActivityWindow: 120000, // 2 minutes
    
    // Autocorrelation filter
    hashBufferSize: 20, // Track last 20 message hashes
    patternThreshold: 3, // 3+ consecutive old hashes = suspicious
    
    // Contextual preservation
    musicalCommandWindow: 60000, // 1 minute for musical repeats
    legitimateRepeatWindow: 30000, // 30 seconds for conversational repeats
    
    // Persistence validation
    persistenceThreshold: 500 // DOM persistence requirement
  };
  
  // Helper functions
  function normText(s) {
    return String(s || '')
      .replace(/\u200B/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }
  
  /**
   * Extract clean text avoiding phantom DOM elements like buttons/icons
   * This fixes the mysterious "J" prefix issue
   */
  function extractCleanText(element) {
    // If it's a direct text node or simple element, use textContent
    if (element.children.length === 0) {
      return normText(element.textContent || '');
    }
    
    // For complex elements, extract only visible text content
    let text = '';
    const walker = document.createTreeWalker(
      element,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: function(node) {
          // Skip text from hidden elements or buttons
          const parent = node.parentElement;
          if (!parent) return NodeFilter.FILTER_SKIP;
          
          const style = window.getComputedStyle(parent);
          if (style.display === 'none' || style.visibility === 'hidden') {
            return NodeFilter.FILTER_SKIP;
          }
          
          // Skip button/icon elements that might contain single letters
          if (parent.tagName === 'BUTTON' || 
              parent.role === 'button' ||
              parent.classList.contains('icon') ||
              parent.classList.contains('btn') ||
              parent.getAttribute('aria-label') ||
              (parent.textContent && parent.textContent.trim().length === 1)) {
            return NodeFilter.FILTER_SKIP;
          }
          
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    
    let node;
    while (node = walker.nextNode()) {
      text += node.textContent;
    }
    
    // Fallback to simple textContent if tree walker gave empty result
    if (!text.trim()) {
      text = element.textContent || '';
      // If we still get a single character that looks suspicious, try inner elements
      if (text.trim().length === 1 && /^[A-Z]$/.test(text.trim())) {
        const innerElements = element.querySelectorAll('div, p, span');
        if (innerElements.length > 0) {
          text = Array.from(innerElements)
            .map(el => el.textContent)
            .filter(t => t && t.length > 1)
            .join(' ');
        }
      }
    }
    
    return normText(text);
  }
  
  function getConvoId() {
    try {
      const parts = window.location.pathname.split('/').filter(Boolean);
      const chatIndex = parts.indexOf('chat');
      if (chatIndex >= 0 && parts[chatIndex + 1]) return parts[chatIndex + 1];
      return parts[parts.length - 1] || 'unknown';
    } catch (e) {
      return 'unknown';
    }
  }
  
  function hashMessage(text, role) {
    // Simple hash function for message content
    let hash = 0;
    const str = \`\${role}:\${text}\`;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
  }
  
  function extractUrls(text) {
    const urls = [];
    const matches = text.match(/https?:\/\/[^\s]+/g);
    if (matches) {
      matches.forEach(url => {
        const clean = url.replace(/[.,;!?)]+$/, '');
        if (!urls.includes(clean)) urls.push(clean);
      });
    }
    return urls;
  }
  
  /**
   * LAYER 1: VELOCITY FILTER - Detects bulk retransmission dumps
   * Flags suspiciously fast message bursts (>5 messages/second)
   */
  function velocityFilter(messageData) {
    const now = Date.now();
    
    // Add current message to velocity buffer
    state.velocityBuffer.push({
      timestamp: now,
      role: messageData.role,
      hash: messageData.hash
    });
    
    // Clean old entries (older than velocity window)
    state.velocityBuffer = state.velocityBuffer.filter(
      entry => now - entry.timestamp < config.velocityWindow
    );
    
    // Count messages in velocity window
    const messagesInWindow = state.velocityBuffer.length;
    const sameRoleInWindow = state.velocityBuffer.filter(
      entry => entry.role === messageData.role
    ).length;
    
    // Check for bulk dump pattern
    if (messagesInWindow > config.velocityThreshold) {
      console.log(\`\${LOGGER_NAME} üö© VELOCITY FILTER: \${messagesInWindow} messages in \${config.velocityWindow}ms\`);
      
      // If most messages are from same role, likely bulk dump
      if (sameRoleInWindow >= config.velocityThreshold) {
        state.stats.filteredByVelocity++;
        return {
          filtered: true,
          reason: 'velocity_bulk_dump',
          details: \`\${messagesInWindow} messages in \${config.velocityWindow}ms, \${sameRoleInWindow} same role\`
        };
      }
    }
    
    return { filtered: false };
  }
  
  /**
   * LAYER 2: TEMPORAL FILTER - Checks message age vs conversation context
   * Filters messages older than conversation window without recent user activity
   */
  function temporalFilter(messageData) {
    const now = Date.now();
    
    // Check if message relates to recent conversation context
    const timeSinceUserActivity = now - state.lastUserInteraction;
    const isOldMessage = state.processedMessages.has(messageData.text);
    
    if (isOldMessage) {
      const lastSeen = state.processedMessages.get(messageData.text);
      const messageAge = now - lastSeen;
      
      // If message is old and no recent user activity, likely historical
      if (messageAge > config.conversationWindow && 
          timeSinceUserActivity > config.userActivityWindow) {
        
        console.log(\`\${LOGGER_NAME} üö© TEMPORAL FILTER: Message age \${Math.round(messageAge/60000)}min, no user activity for \${Math.round(timeSinceUserActivity/60000)}min\`);
        
        state.stats.filteredByTemporal++;
        return {
          filtered: true,
          reason: 'temporal_historical',
          details: \`Message age: \${messageAge}ms, user inactive: \${timeSinceUserActivity}ms\`
        };
      }
    }
    
    return { filtered: false };
  }
  
  /**
   * LAYER 2.5: ECHO DETECTION FILTER - Filters user input echoes
   * Detects when assistant messages exactly match recent user messages (Claude UI echo pattern)
   */
  function echoDetectionFilter(messageData) {
    const now = Date.now();
    
    // Only check assistant messages for echoes
    if (messageData.role !== 'assistant') {
      return { filtered: false };
    }
    
    // Look through recent conversation history for matching user messages
    for (const historyItem of state.conversationHistory.slice(-10)) {
      if (historyItem.role === 'user') {
        const timeDiff = now - historyItem.timestamp;
        
        // If assistant message exactly matches user message within 10 seconds, it's an echo
        if (timeDiff < 10000 && // 10 second window
            historyItem.text.trim() === messageData.text.trim()) {
          
          console.log(\`\${LOGGER_NAME} üö© ECHO FILTER: Assistant echoing user input from \${timeDiff}ms ago\`);
          
          state.stats.filteredByEcho = (state.stats.filteredByEcho || 0) + 1;
          return {
            filtered: true,
            reason: 'user_input_echo',
            details: \`Assistant message exactly matches user input from \${timeDiff}ms ago\`
          };
        }
      }
    }
    
    return { filtered: false };
  }
  
  /**
   * LAYER 3: AUTOCORRELATION FILTER - Detects historical sequence patterns
   * Flags runs of consecutive old message hashes
   */
  function autocorrelationFilter(messageData) {
    // Add current hash to buffer
    state.hashBuffer.push({
      hash: messageData.hash,
      text: messageData.text.slice(0, 30),
      timestamp: Date.now(),
      isHistorical: state.processedMessages.has(messageData.text)
    });
    
    // Maintain buffer size
    if (state.hashBuffer.length > config.hashBufferSize) {
      state.hashBuffer = state.hashBuffer.slice(-config.hashBufferSize);
    }
    
    // Count consecutive historical messages in recent buffer
    let consecutiveHistorical = 0;
    let maxConsecutive = 0;
    
    for (let i = state.hashBuffer.length - 1; i >= 0; i--) {
      if (state.hashBuffer[i].isHistorical) {
        consecutiveHistorical++;
        maxConsecutive = Math.max(maxConsecutive, consecutiveHistorical);
      } else {
        consecutiveHistorical = 0;
      }
    }
    
    // If we're in a run of historical messages, flag it
    if (maxConsecutive >= config.patternThreshold && messageData.isHistorical) {
      console.log(\`\${LOGGER_NAME} üö© AUTOCORRELATION FILTER: \${maxConsecutive} consecutive historical messages\`);
      
      state.stats.filteredByAutocorrelation++;
      return {
        filtered: true,
        reason: 'autocorrelation_pattern',
        details: \`Part of \${maxConsecutive} consecutive historical message sequence\`
      };
    }
    
    return { filtered: false };
  }
  
  /**
   * LAYER 4: CONTEXTUAL PRESERVATION - Protects legitimate repeats
   * Preserves musical commands, user repeats, and intentional patterns
   */
  function contextualPreservation(messageData, filterResults) {
    const now = Date.now();
    
    // Don't override if not already filtered
    if (!filterResults.some(r => r.filtered)) {
      return { preserved: false };
    }
    
    // CRITICAL: NEVER preserve historical messages - they are Claude's retransmissions
    if (messageData.isHistorical) {
      console.log(\`\${LOGGER_NAME} üö´ PRESERVATION BLOCKED: Historical message cannot be preserved\`);
      return { preserved: false };
    }
    
    // Musical command patterns (ChurnRoom use case)
    const musicalCommands = ['PLAY:', 'SEQUENCE:', 'VOLUME:', 'PAUSE:', 'STOP:'];
    const isMusicalCommand = musicalCommands.some(cmd => 
      messageData.text.toUpperCase().includes(cmd)
    );
    
    if (isMusicalCommand) {
      const timeSinceUser = now - state.lastUserInteraction;
      if (timeSinceUser < config.musicalCommandWindow) {
        console.log(\`\${LOGGER_NAME} ‚úÖ CONTEXTUAL PRESERVATION: Musical command within window\`);
        state.stats.preservedByContext++;
        return {
          preserved: true,
          reason: 'musical_command',
          details: \`Musical command within \${config.musicalCommandWindow}ms of user activity\`
        };
      }
    }
    
    // User re-entering old commands (legitimate choice)
    if (messageData.role === 'user') {
      const timeSinceLastSeen = now - (state.processedMessages.get(messageData.text) || 0);
      if (timeSinceLastSeen < config.legitimateRepeatWindow) {
        console.log(\`\${LOGGER_NAME} ‚úÖ CONTEXTUAL PRESERVATION: Legitimate user repeat\`);
        state.stats.preservedByContext++;
        return {
          preserved: true,
          reason: 'legitimate_user_repeat',
          details: \`User repeat within \${config.legitimateRepeatWindow}ms\`
        };
      }
    }
    
    // Natural conversational echoes - ONLY for genuinely fresh content
    // CRITICAL: Never preserve historical bulk dumps, even if they look conversational
    if (messageData.text.length < 50 && 
        !messageData.isHistorical &&
        (now - state.lastUserInteraction) < config.legitimateRepeatWindow &&
        state.velocityBuffer.length < 3) {  // Added: Not during bulk operations
      console.log(\`\${LOGGER_NAME} ‚úÖ CONTEXTUAL PRESERVATION: Fresh conversational echo\`);
      state.stats.preservedByContext++;
      return {
        preserved: true,
        reason: 'conversational_echo',
        details: 'Short fresh message in active conversation'
      };
    }
    
    return { preserved: false };
  }
  
  /**
   * Enhanced user send detection - triggered when user actually sends a message
   */
  function onUserSendMessage(userContent) {
    const now = Date.now();
    console.log(\`\${LOGGER_NAME} üéØ USER SEND DETECTED: "\${userContent.slice(0, 50)}..."\`);
    
    // Check if we're already awaiting a response (prevent multiple triggers)
    if (state.userSendTracking.awaitingResponse) {
      const timeSinceLastSend = now - state.userSendTracking.userSentAt;
      if (timeSinceLastSend < 1000) {
        console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è Ignoring duplicate send event (\${timeSinceLastSend}ms since last)\`);
        return;
      }
    }
    
    // Set up tracking for genuine message and response detection
    state.userSendTracking.awaitingResponse = true;
    state.userSendTracking.responseToContent = userContent;
    state.userSendTracking.userSentAt = now;
    state.userSendTracking.seenUserMessageInStream = false;
    state.userSendTracking.genuineResponseCaptured = false;
    
    // Update lastUserInteraction as well
    state.lastUserInteraction = now;
    
    console.log(\`\${LOGGER_NAME} üìç Tracking genuine user-assistant exchange for: "\${userContent.slice(0, 30)}..."\`);
    console.log(\`\${LOGGER_NAME} üìç User message window: 5s, Response window: \${state.userSendTracking.responseWindow}ms\`);
  }
  
  /**
   * ENHANCED: Check if a message is a genuine response vs historical retransmission
   */
  function checkGenuineResponse(messageData) {
    const { userSendTracking } = state;
    const now = messageData.timestamp;
    
    // FIRST: Check enhanced user detection system
    if (window.genuineUserInputs && messageData.role === 'user') {
      const genuineMarker = window.genuineUserInputs.get(messageData.text);
      if (genuineMarker) {
        const timeSinceMarked = now - genuineMarker.timestamp;
        if (timeSinceMarked < 30000) { // Within 30 seconds of being marked genuine
          console.log(\`\${LOGGER_NAME} üéØ ENHANCED GENUINE USER INPUT: "\${messageData.text.slice(0, 50)}..." via \${genuineMarker.detectionMethod}\`);
          console.log(\`\${LOGGER_NAME} ‚úÖ Bypassing all filters due to enhanced detection\`);
          
          // Set up response tracking
          userSendTracking.awaitingResponse = true;
          userSendTracking.responseToContent = messageData.text;
          userSendTracking.userSentAt = now;
          userSendTracking.seenUserMessageInStream = true;
          userSendTracking.genuineResponseCaptured = false;
          
          return true; // Mark as genuine, bypass all filtering
        } else {
          console.log(\`\${LOGGER_NAME} ‚è∞ Genuine marker expired (\${timeSinceMarked}ms), falling back to original detection\`);
        }
      }
    }
    
    // FALLBACK: Original genuine response detection logic
    if (!userSendTracking.awaitingResponse) {
      return false; // Not expecting any response
    }
    
    // Check if we're within the response time window
    const timeSinceSend = now - userSendTracking.userSentAt;
    if (timeSinceSend > userSendTracking.responseWindow) {
      console.log(\`\${LOGGER_NAME} ‚è∞ Response window expired (\${timeSinceSend}ms)\`);
      return false;
    }
    
    // For user messages: check if this matches our tracked genuine send
    if (messageData.role === 'user' && 
        messageData.text === userSendTracking.responseToContent &&
        !userSendTracking.seenUserMessageInStream &&
        timeSinceSend <= 5000) { // Conservative 5-second window for user messages
      
      userSendTracking.seenUserMessageInStream = true;
      console.log(\`\${LOGGER_NAME} üéØ GENUINE USER INPUT DETECTED: "\${messageData.text.slice(0, 50)}..." bypassing filters\`);
      return true; // Mark as genuine, bypass all filtering
    }
    
    // Track when we see our user message in stream (for assistant response detection)
    if (messageData.role === 'user' && messageData.text === userSendTracking.responseToContent) {
      if (!userSendTracking.seenUserMessageInStream) {
        userSendTracking.seenUserMessageInStream = true;
        console.log(\`\${LOGGER_NAME} üë§ Detected our user message in stream (historical)\`);
      }
    }
    
    // For assistant messages: check if this is the genuine response
    if (messageData.role === 'assistant' && 
        userSendTracking.seenUserMessageInStream && 
        !userSendTracking.genuineResponseCaptured &&
        timeSinceSend >= 500) { // Minimum 500ms delay for genuine response
      
      userSendTracking.genuineResponseCaptured = true;
      userSendTracking.awaitingResponse = false; // Stop waiting
      
      console.log(\`\${LOGGER_NAME} üéâ GENUINE RESPONSE DETECTED: "\${messageData.text.slice(0, 50)}..." after \${timeSinceSend}ms\`);
      console.log(\`\${LOGGER_NAME} ‚úÖ User-Assistant exchange complete, resetting tracking\`);
      return true;
    }
    
    return false;
  }
  
  /**
   * FIXED: Set up integration with enhanced user detection system
   */
  function setupUserSendDetection() {
    console.log(\`\${LOGGER_NAME} üîß Setting up enhanced user send detection integration...\`);
    
    // Check if enhanced user detection is available
    if (window.enhancedUserDetection) {
      console.log(\`\${LOGGER_NAME} ‚úÖ Found enhanced user detection system, integrating...\`);
      
      // The enhanced detection system will populate window.genuineUserInputs
      // Our checkGenuineResponse function will use this data
      
    } else {
      console.log(\`\${LOGGER_NAME} ‚ö†Ô∏è Enhanced user detection not found. To fix user send detection:\`);
      console.log(\`\${LOGGER_NAME} 1. Run the enhanced_user_detection_logger.js first\`);
      console.log(\`\${LOGGER_NAME} 2. Then run this signal processing logger\`);
      console.log(\`\${LOGGER_NAME} ‚ÑπÔ∏è Falling back to enhanced genuine input checking...\`);
      
      // Enhanced fallback: use timing and pattern analysis
      setupFallbackUserDetection();
    }
    
    console.log(\`\${LOGGER_NAME} ‚úÖ User send detection integration active\`);
  }
  
  /**
   * Fallback user detection when enhanced detection isn't available
   */
  function setupFallbackUserDetection() {
    // Monitor for rapid DOM changes that might indicate user input
    let recentDOMChanges = [];
    
    const observer = new MutationObserver((mutations) => {
      const now = Date.now();
      
      // Clean old entries
      recentDOMChanges = recentDOMChanges.filter(change => now - change.timestamp < 5000);
      
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const text = node.textContent || '';
              if (text.trim() && text.length > 5 && text.length < 500) {
                recentDOMChanges.push({
                  text: text,
                  timestamp: now,
                  element: node
                });
                
                // If this looks like a fresh user message, mark it as potentially genuine
                if (text.includes('testmessage') || text.match(/^[A-Z].*[.!?]$/) || text.length < 100) {
                  console.log(\`\${LOGGER_NAME} üîç Potential genuine user input detected: "\${text.slice(0, 30)}..."\`);
                  
                  // Mark as genuine with high confidence if timing is right
                  const timeSinceLastInteraction = now - state.lastUserInteraction;
                  if (timeSinceLastInteraction < 10000) { // Within 10 seconds of interaction
                    markContentAsGenuine(text, 'fallback_timing_analysis');
                  }
                }
              }
            }
          });
        }
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Fallback user detection active\`);
  }
  
  /**
   * Mark content as genuine user input
   */
  function markContentAsGenuine(content, method) {
    window.genuineUserInputs = window.genuineUserInputs || new Map();
    window.genuineUserInputs.set(content, {
      content: content,
      timestamp: Date.now(),
      detectionMethod: method,
      genuine: true
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Marked as genuine: "\${content.slice(0, 30)}..." via \${method}\`);
  }
  
  /**
   * Send to server with signal processing metadata
   * Server handles dual logging automatically:
   * - chatverbose.log: Gets everything (always)
   * - chat.log: Gets only clean messages (filtered by server + our signal processing)
   */
  function sendToServer(payload, signalProcessingDecision) {
    // Mark as noise if filtered by signal processing
    // This will prevent it from reaching chat.log but allow it in chatverbose.log
    if (signalProcessingDecision.filtered) {
      payload.metadata.isSignalNoise = true;
      payload.metadata.signalProcessingFilter = signalProcessingDecision.filteredBy;
    }
    
    fetch('http://localhost:8788/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    })
    .then(response => response.text())
    .then(result => {
      if (signalProcessingDecision.filtered) {
        state.stats.verboseLogEntries++; // Only in verbose
        console.log(\`\${LOGGER_NAME} üìã VERBOSE ONLY:\`, payload.role, payload.text.slice(0, 30));
      } else {
        state.stats.cleanLogEntries++; // In both logs
        console.log(\`\${LOGGER_NAME} ‚úÖ BOTH LOGS:\`, payload.role, payload.text.slice(0, 30));
      }
    })
    .catch(error => {
      console.log(\`\${LOGGER_NAME} ‚ùå Server log failed:\`, error.message);
    });
  }
  
  /**
   * MAIN SIGNAL PROCESSING PIPELINE
   */
  function processMessage(element, role, text, context = {}) {
    const now = Date.now();
    
    state.stats.totalMessages++;
    
    const messageData = {
      element: element,
      role: role,
      text: text,
      hash: hashMessage(text, role),
      timestamp: now,
      isHistorical: state.processedMessages.has(text)
    };
    
    console.log(\`\${LOGGER_NAME} üîÑ PROCESSING: \${role} - "\${text.slice(0, 50)}" [len=\${text.length}] [element=\${element.tagName}]\`);
    
    // Run through filter layers
    const filterResults = [
      velocityFilter(messageData),
      temporalFilter(messageData),
      echoDetectionFilter(messageData),
      autocorrelationFilter(messageData)
    ];
    
    // Check if this is a genuine response (overrides filtering)
    const isGenuineResponse = checkGenuineResponse(messageData);
    
    // Check contextual preservation
    const preservation = contextualPreservation(messageData, filterResults);
    
    // Determine final disposition - genuine responses bypass filtering
    let isFiltered, filteredReasons;
    if (isGenuineResponse) {
      isFiltered = false; // Genuine responses are never filtered
      filteredReasons = [];
      console.log(\`\${LOGGER_NAME} üéØ GENUINE RESPONSE OVERRIDE: Bypassing all filters\`);
    } else {
      isFiltered = filterResults.some(r => r.filtered) && !preservation.preserved;
      filteredReasons = filterResults.filter(r => r.filtered).map(r => r.reason);
    }
    
    // Create log payload
    const urls = extractUrls(text);
    const payload = {
      platform: 'claude',
      role: role,
      text: text,
      urls: urls,
      metadata: {
        artifacts: [],
        tools: [],
        streaming: false,
        messageLength: text.length,
        directLogger: true,
        timestamp: now,
        conversationId: getConvoId(),
        signalProcessing: {
          filtered: isFiltered,
          filteredBy: filteredReasons,
          preserved: preservation.preserved,
          preservedBy: preservation.reason || null,
          filterDetails: filterResults.filter(r => r.filtered).map(r => r.details),
          velocityBufferSize: state.velocityBuffer.length,
          isHistorical: messageData.isHistorical,
          isGenuineResponse: isGenuineResponse,
          isGenuineUserInput: isGenuineResponse && messageData.role === 'user'
        },
        detectionMethod: context.detectionMethod || 'signal_processing'
      }
    };
    
    // Update state
    state.processedMessages.set(text, now);
    state.conversationHistory.push({ text, role, timestamp: now, filtered: isFiltered });
    
    if (role === 'user') {
      state.lastUserInteraction = now;
    }
    
    // Log to appropriate destinations
    if (isFiltered) {
      console.log(\`\${LOGGER_NAME} üö´ FILTERED (\${filteredReasons.join(', ')}):\`, text.slice(0, 50));
      sendToServer(payload, 'verbose'); // Only to verbose log
    } else {
      console.log(\`\${LOGGER_NAME} ‚úÖ PASSED:\`, text.slice(0, 50));
      sendToServer(payload, 'both'); // To both logs
    }
    
    // Maintenance
    if (state.conversationHistory.length > 50) {
      state.conversationHistory = state.conversationHistory.slice(-25);
    }
  }
  
  /**
   * Initialize DOM monitoring (same as before but with signal processing)
   */
  function setupMessageCapture() {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.addedNodes) {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              setTimeout(() => {
                analyzeNodeForMessages(node);
              }, config.persistenceThreshold);
            }
          });
        }
      });
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Signal processing message capture active\`);
  }
  
  function analyzeNodeForMessages(node) {
    try {
      const messageSelectors = [
        '[data-message-author-role]',
        '[data-message-id]',
        'article',
        '[role="article"]'
      ];
      
      let messageElement = null;
      let detectedRole = null;
      
      for (const selector of messageSelectors) {
        try {
          if (node.matches && node.matches(selector)) {
            messageElement = node;
            detectedRole = detectMessageRole(node);
            break;
          }
          
          const foundElement = node.querySelector(selector);
          if (foundElement) {
            messageElement = foundElement;
            detectedRole = detectMessageRole(foundElement);
            break;
          }
        } catch (e) {
          // Skip invalid selectors
        }
      }
      
      // Fallback content analysis
      if (!messageElement && node.textContent) {
        const text = normText(node.textContent);
        if (text.length > 5 && text.length < 2000) {
          const role = detectMessageRole(node);
          if (role !== 'unknown') {
            messageElement = node;
            detectedRole = role;
          }
        }
      }
      
      if (messageElement && detectedRole && detectedRole !== 'unknown') {
        // FIXED: Extract text more carefully to avoid phantom elements
        let text = extractCleanText(messageElement);
        
        // DEBUG: Log raw text extraction
        console.log(\`\${LOGGER_NAME} RAW DOM TEXT: "\${text}" from element:\`, messageElement.tagName, messageElement.className);
        
        if (text) {
          processMessage(messageElement, detectedRole, text, { 
            detectionMethod: 'signal_processing_dom_mutation' 
          });
        }
      }
    } catch (error) {
      console.error(\`\${LOGGER_NAME} Error analyzing node:\`, error);
    }
  }
  
  // Basic role detection (simplified for now)
  function detectMessageRole(element) {
    const roleAttr = element.getAttribute('data-message-author-role');
    if (roleAttr) return roleAttr;
    
    const text = normText(element.textContent || '');
    const timeSinceUser = Date.now() - state.lastUserInteraction;
    
    // Pattern-based fallback
    if (text.includes('JSEQUENCE:') || text.includes('JPLAY:') || text.includes('testmessage')) {
      return 'user';
    }
    
    // More flexible assistant response detection
    if (text.match(/(seq_ok|play_ok|vol_ok|okay\d+)/i) || text.includes('_ok')) {
      return 'assistant';
    }
    
    // Check if this looks like an assistant response (short, follows user message)
    if (text.length < 100 && timeSinceUser < 30000 && timeSinceUser > 500) {
      // Exclude obvious user patterns
      if (!text.includes('testmessage') && !text.toLowerCase().includes('respond')) {
        return 'assistant';
      }
    }
    
    // Conversation flow heuristic
    if (timeSinceUser < 30000 && timeSinceUser > 1000) {
      return 'assistant';
    }
    
    return 'unknown';
  }
  
  // Initialize
  function initialize() {
    console.log(\`\${LOGGER_NAME} Initializing signal processing logger...\`);
    console.log(\`\${LOGGER_NAME} Filter thresholds:\`);
    console.log(\`  - Velocity: \${config.velocityThreshold} msgs/\${config.velocityWindow}ms\`);
    console.log(\`  - Temporal: \${config.conversationWindow}ms conversation window\`);
    console.log(\`  - Pattern: \${config.patternThreshold}+ consecutive = suspicious\`);
    console.log(\`  - Contextual: Musical commands preserved for \${config.musicalCommandWindow}ms\`);
    
    setupMessageCapture();
    setupUserSendDetection(); // Set up DOM event listeners for user send detection
    
    // Mark existing messages to avoid processing history
    const existingElements = document.querySelectorAll('*');
    let markedCount = 0;
    
    existingElements.forEach(el => {
      const text = normText(el.textContent || '');
      if (text && text.length > 3 && text.length < 500) {
        state.processedMessages.set(text, state.sessionStart - 1000);
        markedCount++;
      }
    });
    
    console.log(\`\${LOGGER_NAME} ‚úÖ Initialized - marked \${markedCount} existing elements\`);
  }
  
  // Start the signal processing logger
  initialize();
  
  // Expose for debugging and monitoring
  window.signalProcessingLogger = {
    getState: () => ({
      ...state,
      config: config,
      velocityBuffer: state.velocityBuffer.map(v => ({ 
        timestamp: v.timestamp, 
        role: v.role, 
        age: Date.now() - v.timestamp 
      }))
    }),
    getStats: () => state.stats,
    clearState: () => {
      state.processedMessages.clear();
      state.conversationHistory = [];
      state.velocityBuffer = [];
      state.hashBuffer = [];
      state.temporalWindow = [];
      Object.keys(state.stats).forEach(key => state.stats[key] = 0);
      console.log(\`\${LOGGER_NAME} State and stats cleared\`);
    }
  };
  
  console.log(\`\${LOGGER_NAME} ‚úÖ Signal processing logger ready!\`);
  console.log('Debug: window.signalProcessingLogger.getState(), .getStats(), .clearState()');
  
})();`;
                    
                    if (signalScript.length > 100) {
                        eval(signalScript);
                        log('‚úÖ Signal processing script injected');
                    } else {
                        log('‚ùå Signal script is too short or empty');
                    }
                } catch (error) {
                    log('‚ùå Signal script injection failed: ' + error.message);
                }
                
                // Test connection after injection
                setTimeout(testConnection, 1000);
                
                // Check stats after injection
                setTimeout(checkStats, 2000);
                
            }, 500);
        }
        
        // Auto-inject on page load
        window.addEventListener('load', () => {
            log('üîÑ Page loaded, auto-injecting scripts...');
            testConnection();
            setTimeout(injectScripts, 1000);
        });
        
        // Also inject immediately
        log('üîÑ Immediate injection starting...');
        injectScripts();
    </script>
</body>
</html>